# HW0
<p>My is Ashanti Long and I am a junior at the College of Chareston. I getting my Bachelor of Science in Computer Science and Math</p>


# HW1: Chapter 1

### 1.3 Four important attributes of professional software are:

<div style = "color:red">
    Maintainability
    Dependability and security
    Efficiency
    Acceptability/Usability
</div>

###  1.4 The four most important attributes are essentially maintainability, dependability, efficiency (performance) and usability. Other attributes that may be significant could be reusability (can it be reused in other applications), distributability (can it be distributed over a network of processors), portability (can it operate on multiple platforms e.g laptop and mobile platforms) and inter-operability (can it work with a wide range of other software systems). Other attributes that are also significant are:



<div style = "color:red">
  
    Response time (non-functional attribute)
    Interactivity
    Reliable
    Evolution
  
</div>
### 1.8 Discuss whether professional software engineers should be licensed in the same way as doctors or lawyers. 

<div style = "color:red">
  
    -I believe that professional engineers should be certified in the same ways as doctors and lawyers because like doctors and lawyers you understand who has the right credential. Software is extremely important in today’s world and it is increasing higher than any occupation . For instance, high security government software should not be made by just any guy with some knowledge of programs. We should have a way to differentiate between the people who should be in charge of creating and fixing critical programs and those who aren’t quite ready for that type of responsibility
  
</div>


### 1.9: For each of the clauses in the ACM/IEEE Code of Ethics shown in Figure 1.4, propose an appropriate example that illustrates that clause. -PUBLIC – Software engineers shall act consistently with the public interest. A software engineer will create non-malicious software that is robust enough to maintain the welfare of its stakeholders.


<div style = "color:red">
  
    CLIENT AND EMPLOYER – Software engineers shall act in a manner that is in the best interests of their client and employer consistent with the public interest. A software engineer will create software that is to the standard/specifications of those who request it.
    PRODUCT – Software engineers shall ensure that their products and related modifications meet the highest professional standards possible. A software engineer will create software that is acceptable, dependable, secure, efficient, and maintainable.
    JUDGMENT – Software engineers shall maintain integrity and independence in their professional judgment. A software engineer will practice good ethics in their profession despite any negative pressure they may receive.
    MANAGEMENT – Software engineering managers and leaders shall subscribe to and promote an ethical approach to the management of software development and maintenance
    PROFESSION – Software engineers shall advance the integrity and reputation of the profession consistent with the public interest. A software engineer will ensure that a software’s development is at least up to industry standard if not better.
    COLLEAGUES – Software engineers shall be fair to and supportive of their colleagues. A software engineer is an understanding, unbiased and dedicated worker within their team.
    SELF – Software engineers shall participate in lifelong learning regarding the practice of their profession. A software engineer continues learning as the standards of software engineering change, such that they may maintain the industry standard for development. 1.10 To help counter terrorism, many countries are planning or have developed computer systems that track large numbers of their citizens and their actions. Clearly, this has privacy implications. Discuss the ethics of working on the development of this type of system.
    In working on the development of this type of system, there is a fine line between what is ethical and what is not. On one hand, citizens do not want to be tracked because they want to maintain privacy, but on the other hand it is within public interest to prevent terrorist action. Therefore, the best solution to this problem is assuring that the privacy of those being tracked is protected by the software. This means a strong consideration for the security and dependability of the software, as well as a high ethical standard set for the engineers developing it.
    
</div>
 

# HW2: Reflections on software engineering practices

<div style = "color:red">
  
    Today I will be discussing with you: Silver Bullet while using Cherry Picking and Scientific Method, Google Copy Repo and Make Se More Ethical as information to back up certain things or give examples . “Silver Bullet” by Frank Brookes discusses the monster known as Software engineering. When I was growing up my sibling use to babysit me while my parents were at work. We would always watch anime because my brother went to Japan with my father for several years and that where he was introduced to anime, loved it and wanted to introduce it to us. I remember the first anime I ever watch was アンパンマン and ドラゴンボール. The plot was the same, the evil villain reck havoc on the city, planet, and hero friends etc. And everyone would wait for the hero to save the day to make thing easier for everyone and to end everyone suffering. One watches horror movies like Blade, Underworld etc. Where vampire reach havoc on the world and as you are getting bit by a vampire you just think within your head that you wish you had a silver bullet to kill this vampire and make thing easier for you and end the suffering. The point I am trying to make, and the point Brooke made is that there is no silver bullet in software engineering. We as developer might think the solution is nontechnical and straightforward but software can become a disaster like a tsunami or as frightening as a vampire or werewolf. From: miscommunication, to complex structure, flawed product, unaffordable budget etc. I think we as developer or as programmer wished we had a silver bullet like hardware has and reduce productivity and production with reduction of cost. As you read “Silver Bullet”, Brooke categories software difficulties into two groups: essential difficulties which discusses the difficulties that was inherent by the software itself which are problem that unavoidable due to the complex nature of the software. Then accidental difficulties which is the result of one overcomplicating things for themselves and making things harder. Which I think relates to the “Cherry Picking and Scientific Method” article. Cherry Picking is a very misleading and untrustworthy method which relate to making thing more difficult for yourself. Cherry Picking does not provide all the test cases for the experiment and it hard to find pattern in data so I would categories this as accidental difficulties. Then Brook goes on discussing the source of essential difficulties and why there will never be a silver bullet. They are listed as: complexity, conformity, changeability, and invisibility. A example of one of these essential difficulties is google code repo. The monolithic model that google made surely makes it easier to comprehend the complexity of the codebase, since there is no coercion of repository boundaries between dependencies. However, as the scale increases, code discovery can become more difficult. Which many problems that arise in software engineering is the nonlinear increase in size. So, what can we do to fix these problems? We should reuse, incremental development and nurture your software engineers. I think nurturing our software engineers and make sure they follow the right path and ethics. Software developers are a huge part of today society. They are the one protecting our infrastructure. They write 1000 of lines of code today to model today society and impact people live. They protect and secure our information from hackers. Software engineering is in everything: banking, surveillance, drones, security, cars and etc.. They truly impact the world .
    
</div>


# HW3: Chapters 11 & 12



### 11.4 What is the common characteristic of all architectural styles that are geared to supporting software fault tolerance?

 <div style = "color:red">
   
     A system that provides fault tolerance will include redundant and diverse hardware and software.
   
     
 </div>



### 11.7 It has been suggested that the control software for a radiation therapy machine, used to treat patients with cancer, should be implemented using N-version programming. Comment on whether or not you think this is a good suggestion.
  

<div style = "color:red">
  
    Using multi-version programming to evaluate radiation therapy is a good method. If we have multiple system running cohesively on a hardware, which is set in the same settings, then if these two systems calculate the same output, the output should be correct. I am not sure how many would be required to produce the same output, but based on probability, the more machines required to produce the same output, the safer it is
  

 </div>


### 11.9 Explain why you should explicitly handle all exceptions in a system that is intended to have a high level of availability


 <div style = "color:red"> 
   
     -This is due to if they are not handled then the software will shut down. Software developers must provide exception for anything that could be detected and possible exceptions that may arise. If the software fails and the system shuts down 12.5 A train protection system automatically applies the brakes of a train if the speed limit for a segment of track is exceeded, or if the train enters a track segment that is currently signaled with a red light (i.e., the segment should not be entered). There are two critical-safety requirements for this train protection system: The train shall not enter a segment of track that is signaled with a red light. The train shall not exceed the specified speed limit for a section of track. Assuming that the signal status and the speed limit for the track segment are transmitted to on-board software on the train before it enters the track segment, propose five possible functional system requirements for the onboard software that may be generated from the system safety requirements.
   
</div>
  



### 12.5 A train protection system automatically applies the brakes of a train if the speed limit for a segment of track is exceeded, or if the train enters a track segment that is currently signaled with a red light (i.e., the segment should not be entered). There are two critical-safety requirements for this train protection system: The train shall not enter a segment of track that is signaled with a red light. The train shall not exceed the specified speed limit for a section of track. Assuming that the signal status and the speed limit for the track segment are transmitted to on-board software on the train before it enters the track segment, propose five possible functional system requirements for the onboard software that may be generated from the system safety requirements.


 <div style = "color:red">   
   
     Check whether the signal status is green for the upcoming section of a track (a)
     Check whether train is going faster or slower than the intended speed limit for that section of track (b)
     If (b) calculates that the train is going faster, apply brakes gently
     If (b) calculates that the train is going slower, speed up gently
     If (a) is red, search for another option of track segment that has a green signal status
     If either (a) or (b) are not within the critical safety requirements, alert the human conductor
   

   </div>


# HW4: Reflections on software failures

 <div style = "color:red"> 
   </p>
What is the difference from “Fault”, “Error” and “Failure? Well, this would be all categorized as dependability that we read in chapter 13 and 14. If we talk in term of dependability it is the system property that cohesively unite elements such attributes as reliability, availability, safety, security, survivability, maintainability. The aim of the reflection is to summarize basic concepts of dependability occur in several articles: Thearac-25 Accident, 2010 Radiation Follies, FBI Auto Warning, Spacecraft Accident, FBI Fiasco 2005, FBI Fiasco 2010, Why Software Project Fail etc.. A structured view of dependability follows, according to a) the threats, i.e., faults: It is a condition that causes the software to fail to perform its required function., errors: refers to difference between Actual Output and Expected output and failures: It is the inability of a system or component to perform required function according to its specification., b) the attributes, and c) the means for dependability, that are fault prevention, fault tolerance, fault removal and fault forecasting. If we look at the article Thearac-25 Accident which discusses radiation therapy machine. One can see it is a major breach security and dependability. It is basically a X-Ray or a combination of electron to kill cancer cell deep in the body. However, this type of treatment killed many people due to overdose of radiation in the body. This is “Fault” because it was discovered that there were many bugs in the software meaning the bug was the component which was the turntable and magnets being in the wrong position and in causing overdosing patients. Preliminary risk assessment and analysis aim to identify the generic security risks for a system and its associated data. This risk assessment is an important input to the security requirements engineering process. Security requirements can be proposed to support the general risk management strategies of avoidance, detection, and mitigation. Which they failed to do. Which is a faulty software design. Then if we look at 2010 Radiation Follie is another radiation overdose case. While in some cases technicians did not know how to properly administer the test, interviews with hospital officials and a review of public records raise new questions about the role of manufacturers, including how well they design their software and equipment and train those who use them. If we look at the article “Why So Project Fail” it is stated that 55 % project fail due to the lack of time, staff and resources. Hospital are populated throughout the world and the amount of equipment and software they need only increases so we can assume that software engineers are pressured to produce fast and efficient software which can connect to the lack of time. Both causes of overdose can also relate to the lack of testing that manufacturers did. But when there’s a lot of pressure to deliver on a project at a certain time, testing is typically the first thing to be abandoned. If we look at the article Spacecraft Accidents which is collection of software failure in spacecraft and look at some of the accidents. For example: Ariane 501 which flew off course. If we look at the accident report we can discover the loss of information was due to specification and design errors in the software of the inertial reference system. The software was reused from the Ariane 4 and included functions that were not needed for Ariane 5 but were left in for “commonality.” In fact, these functions were useful but not required for the Ariane 4 either. However, I just see this a laziness and not wanted to modify such changes to be efficient thus I find this as an exposure which is possible loss or harm to a computing system. This can be loss or damage to data or can be a loss of time and effort if recovery is necessary after a security breach. If we look at the rest of the article we will see the same pattern of common trends that is breach of security such as : insufficient time, inadequate planning, unclear on project specifications, to many people on one project and lack of testing



 </div>  


# HW5: Chapter 4 and Reflections
 
 <div style = "color:red">
   
     -The reading for today: magicial number 7 , tire preasure monitering system , spy car act of 2015 and test driven development showed importance of incorporating Test-Driven Development while also showing how the establishing of the requriment of non-functional and functional before one can reach the development phase.Doing nonfunctional and functional is essential to the growth. If a developer does not have a clear understanding of these concepts they could forget about thing that could impact the film which could lead to a catastrophic errors and running out of time. If we look at “Magical Number Telephone number Seven” it show that if we do not understand functional and non-functional requirement we can easily forget certain layout and forget certain feature and that can delay us a lot as developers , especially if we are discussing or working on big projects.
   
  </div>



### 4.5 Using the technique suggested here, where natural language descriptions are presented in a standard format, write plausible user requirements for the following functions: 


<div style = " color: red">
  
    An unattended petrol (gas) pump that includes a credit card reader. The customer swipes the card through the reader then specifies the amount of fuel required. The fuel is delivered and the customer’s account is debited. The system shall be sure that there is fuel available. The system shall determine the price for the specified amount of fuel. The system shall deliver the correct amount of fuel. The system shall shut off once specified fuel amount is reached. The system shall debit the customer’s account for the price of the amount of fuel delivered. 
    • The cash-dispensing function in a bank ATM. The function shall verify the validity of the card used. The function shall verify that the PIN used matches the specified card and account. The function shall make sure the account has the amount specified. The function shall be sure the dispenser has the available funds requested. The function shall dispense the specified amount of cash. The spelling-check and correcting function in a word processor. The function shall alert the reader to a misspelling. The function shall check whether the targeted word is in the specified (installed) dictionary. The function shall attempt to match the typed word to the closest word in the dictionary. The function should offer suggestions for corrections of misspelled words. The function should offer to ignore a misspelling. The function should offer to add a spelling to the dictionary. 
    
  
</div>

  ### 4.6 Suggest how an engineer responsible for drawing up a system requirements specification might keep track of the relationships between functional and non-functional requirements.’


 <div style = "color:red"> 
   
-A diagram or list would be ways that would allow an engineer to keep track of the requirements as well as the connections between them. A diagram would allow visual connections and relationships between functions to be easily recognized rather than the confusion that could result from keeping everything separate in lists.
   
</div>


### 4.7 Using your knowledge of how an ATM is used, develop a set of use cases that could serve as a basis for understanding the requirements for an ATM system.

  
 <div style = "color:red"> 
   
     Withdraw funds: By swiping their card through the card-reader, the user then inputs a PIN (personal identification number) to verify access to the account. The records of the bank who holds the account are checked, and the account is then confirmed. The user may then choose from a list of options on the ATM screen. The user can input an amount (or may have the option to choose from a predetermined amount) to be withdrawn from their bank account. The system confirms that the user has enough money in their account before dispensing the specified amount of cash. After the cash is dispensed, the user will confirm that the transaction is complete by pressing the button on the screen. They are then logged out of their account and the ATM is prepared for the next user. Transfer funds: After confirming access to their account by the process aforementioned, the user is again presented with a list of options on the screen. By choosing the button to transfer money, the user can choose to move money between their own accounts, for example, transferring money from their savings account into a checking account, or into the account of another user provided they have the account number to transfer the money into. The user must then confirm the amount and the destination, the money is transferred and the transaction is complete as the user logs out of the account and the ATM is prepared for the next user. Check balance: By again confirming access to their account, the user is presented with a list of options. The user may then choose the option for checking their account balance on the screen. The ATM accesses the bank records for the specified account and displays it on the screen for the user to see. The user may then choose to press “End” therefore logging out of their account on the ATM.
   
  </div>


# HW6: Chapter 2



### 2.1 Suggest the most appropriate generic software process model that might be used as a basis for managing the development of the following systems. Explain your answer according to the type of system being developed:

 <div style = "color:red"> 
   
    • A system to control antilock braking in a car - the waterfall process is usually adapted for safety-critical systems because of the higher amount of analysis and documentation required before implementation. Because testing is a huge part of finalizing the software, it seems the waterfall model is the most appropriate generic software process. • A virtual reality system to support software maintenance - software maintenance is best done through versions and updates over long amounts of time, which would be the incremental development process. • A university account system that replaces an existing system - the integration and configuration process seems like it would be the best choice for a new account system as it takes reusable components (like formulas and sums) and integrates them into a new system and setting. • An interactive travel planning system that helps users plan journeys with the lowest environmental impact - I think this could be more than one of the software process models, but I will say incremental development. A planning system would need to be adaptable and have multiple versions.
   </p>
  </div>
# HW7: Chapter 5 & 6

### 5.3  You have been asked to develop a system that will help with planning large-scale events and parties such as weddings, graduation celebrations, and birthday parties. Using an activity diagram, model the process context for such a system that shows the activities involved in planning a party (booking a venue, organizing invitations,,etc. ) and the system elements that might be used at each stage.

![Picture.5.3](/Picture5.3.png "Picture5.3")

### 5.5 Develop a sequence diagram showing the interactions involved when a student registers for a course in a university. Courses may have limited enrollment, so the registration process must include checks that places are available. Assume that the student accesses an electronic course catalog to find out about available courses

![Picture.5.5](/Picture5.5.png "Picture5.5")


### 5.7   Based on your experience with a bank ATM, draw an activity diagram that models the data processing involved when a customer withdraws cash from the machine

![Picture.5.7](/Picture5.7.png "Picture5.7")


### 5.8  Draw a sequence diagram for the same system. Explain why you might want to develop both activity and sequence diagrams when modeling the behavior of a system.

![Picture.5.8](/Picture5.8.png "Picture5.8")

### 6.4. Draw diagrams showing a conceptual view and a process view of the architectures of the following systems:
•	A ticket machine used by passengers at a railway station.

![Picture.6.4](/Picture6.4.png "Picture6.4")

•	A computer-controlled video conferencing system that allows video, audio, and computer data to be visible to several participants at the same time

![Picture.6.42](/Picture6.42.png "Picture6.42")

•	A robot floor-cleaner that is intended to clean relatively clear spaces such as corridors. The cleaner must be able to sense walls and other obstructions

![Picture.6.43](/Picture6.43.png "Picture6.43")

# HW8: "Mythical Man Month"

 <div style = "color:red"> 
 The Mythical Man-Month is just a collection of essays on Software Engineering within a book on software engineering and project management by Fred Brooks first published in 
In my opinion Chapters 5, 6, 7 8, 9,10, 11, 12 ,13 ,14 15 seem unnecessary I believe the mid-section of the essay could be skipped because they just restate things.  It feels outdated with the verbal usages making it seem somewhat sexist and not allowing women in the profession. I felt like Brooks purposely uses the pronoun "he" for every sentence. I would recognize that during that age many women weren’t in that felid but still. I thought chapter 7, and the later chapter was educational, and I learned a lot from them. These chapter mostly talking about why software development costs so much and why adding more engineers to a project is unlikely to speed productivity linearly. I think overall the most important thing to take away from this is communication and organization and managing added complexity. 
It makes me wonder why engineering interviews select so much for problem-solving and hardly at all for communication and organization skills, or the ability to manage growing complexity. The chapter i think you should read are: 1,2,3,4 7, and 16+. Chapter 5: This is basically telling why everyone first attempt is horrible and how to prepare thing around it and chapter 11 restate that for that and design around it. Chapter 11 mostly re-iterates this.Chapter 6 talk about the birth of OS/360 manual became.  I think this is not really important becasue it out of date and most things use auto-generated websites. In the past  worke would have stack of paper at their desk. Brooks chronicles the problems of maintaining such a manual, and how switching to a microfiche manual helped in some ways, but hindered in others.Chapter 10 talks about important documents for a software organization. This hold great importance for a big compnay and enterpise but not for start up .Chapter 13 just  explains the properties of a good testing framework, basically preaching the importance of unit tests and integration tests. This is taken for granted in the modern work-place as every company at least knows of the importance. Chapter 14 similarly explains the importance of milestones. Again, this is taken for granted in the modern work-place. Kanban, Agile, and every other Software Development Life Cycle mostly revolves around this.Chapter 15 spells out the importance of documentation. But peering into the future, Brooks sees this becoming obsolete, admitting that newer languages of the time, like Ada, allowed for code to be almost human readable. Nowadays, code is human readable enough that most programmers prefer for code to be "self-documenting". It's always up for debate if the code written is in fact self-documenting. But the importance of documentation is constantly diminishing as languages become ever-more declarative, and systems are better and better designed.
    </div>
    
# HW9: 8.7, 8.10, reflections on reading

### 8.7  Write a scenario that could be used to help design tests for the wilderness weather station system.

<div style = "color:red">
   Billy works for a wilderness weather station out in Lander, WY. He spends a lot of time at work because he often gets snowed in and has to spend the night. This gives him      plenty of time to test the weather station software. First, he has to log onto the system using his weatherman username and password. 

  Billy usually first checks the status of the satellitle communcations (SatComm) and the regular communications (Commslink) link to ensure that the summary is being collected   from up-to-date data. He then will request a weather data summary report from satellite communications and receive an acknowledgement of this request. 

 Billy knows the weather station will send him a report if it is unable to collect data via the Commslink and it will also acknowledge that he requested a report. Always alone and drinking coffee, Billy looks forward to receiving the summary report of the weather data to give him something to do on long snowy days at work. 

 </div>
 
 
 

### 8.10  A common approach to system testing is to test the system until the testing budget is exhausted and then deliver the system to the customers. Discuss the ethics of this approach for systems that are delivered to external customers. 

  <div style = "color:red">
    
This is not a very ethical approach. Testing is time-intensive and often leads to changes in software as the tests reveal issues. The testing period should have plenty of time devoted to it to ensure that a customer is getting, if not a totally bug-free product, at least a product that has undergone extensive testing before it was deemed appropriate to receive money for. A testing budget should also be a little bit larger because of its importance to a project. 

If a software company develops and delivers software to an external customer without putting in significant testing time, then how can the software company be sure that they will get that customer back? A company can only ensure returning customers if they have put the time and effort into making their product the best it can be for the requirements asked for and tested it effectively to the best of their abilities.
  </div>


### Reflection

<div style = "color:red">
    
Intro to testing explain many reasons for testing. The whole idea of intro to testing and we can conclude that every software application has some defects embedded in it       but not every defect is a threat to the system. Due to this we can accomplish a lot with software testing. Testing helps in evaluating the quality of software.
There are many reasons why software testing has gained so much of importance in the field of information technology. Firstly, testing helps in reducing the overall cost of     the software development project. If testing is ignored in the initial development stages to save a small amount of money then it may turn out to be a very expensive matter    later because as you move on with development process it becomes more and more difficult to trace back defects and rectifying one defect somewhere can introduce another        defect in some other module.
The requirement is finalized after several discussions with the client. Testing ensures that the software behaves and looks exactly like what is mentioned in the               requirements specification document, so that when software is delivered to the client there are no arguments about the variation from the original requirements. Software       testing helps in strengthening the market reputation of a company. Well tested software is of good quality and good quality means better feedback and reviews.
 In order to achieve best results it is important to organize all your testing efforts and this is what this Software Testing Training provided by International Software        Test Institute is all about. Software testing cannot be fruitful without proper planning. To live up to the expectations of the client it is important to plan every step       carefully. A lot of things need to be considered in order plan your testing efforts. Software testing should be planned keeping budget, schedule and performance in mind in     order to achieve best results. All testing activities require planning. It is important to outline a test plan that will give in details about how each activity will be         carried out. Test plan is alsorequired to ensure that all aspects of the software are covered thoroughly and there is no repetition of testing process so that time and effort   is not wasted.The latest trend now is to involve the testing team in specification writing process. It is important that the testing team understands the requirements of the client clearly as the entire development is based on the requirement defined by the client. Anything that is not in line with the requirement is a defect. So, the testing team should have a clear idea about what the final outcome of running software should be like. As a matter of fact it is important to start writing test cases in parallel to specification writing. This will help the testers analyze whether all the requirements are testable or not. When you write test cases in parallel to specification writing process you will think critically about the specifications and you will know if there is an issue with the requirement or if there is something that cannot be developed
 
 </div>

# HW10: Ex 15.10


    
### 15.10  The reuse of software raises a number of copyright and intellectual property issues. If a customer pays the software contractor to develop a system, who has the right to reuse the developed code? Does the software contractor have the right to use that code as a basis for a generic component? What payment mechanisms might be used to reimburse providers of reusable components? Discuss these issues and other ethical issues associated with the reuse of software.

  <div style = "color:red">
    As a student who taken many classes for example grpahic design , me and my classmante disccused problems before in the design industry with confusion as to who has rights       to a created product. Software reuse seems like a similar issue and I think there will forever be a debate between groups who want to share everything and groups who want       acknowledgement of their achievements and therefore the rights to their own software. The former group will argue that they have built working software and its reuse is         important in order to save time and expenditure on creating more software that works the same way in a future product. The latter group will argue that they have the sole       right to reuse software that they developed. 

   I think, at this point in my student career , that I at least believe in rewriting the code portion of software. I think it is better to go over old solutions and improve      them, even if they end up performing the same tasks as the older version. Otherwise, how is code ever going to improve if we just copy old solutions and never learn from        them?
</div>




# HW11: Chapter 9"

### 9.8 Briefly describe the three main types of software maintenance. Why is it sometimes difficult to distinguish between them?

<div style = "color:red">
    Bug Fixing - this is repairing faults found in the software after it has been launched. The bugs are there possibly because testing was not as thorough as it should have       been or clients have exposed bugs by using the software in unexpected ways. Coding errors, design errors, and requirement errors are the least, middle, and most expensive       to correct, respectively. 
    Modifying software to work in a new environment - when the hardware or platform that the system was built to run on changes, then the software must change as well in order     to be compatible and avoid being obsolete.
    Implementing new or changed requirements - software must be updated or changed so that it conforms with any new requirements. 
    It is sometimes difficult to distinguish between the different types of maintenance because they are often given different names and also because faults that arise within a    system can maybe have overlapping maintenance requirements. 

</div>




### 9.10  Do software engineers have a professional responsibility to develop code that can be easily maintained even if their employer does not explicitly request it?

<div style = "color:red">
    
Yes definitely! Software development and maintenance are not separate activities. It is important to keep in mind how a system will need to be maintained if, for example, it is a system that is meant to last a long time and will have a revolving-door of developers working on it. A software developer who cares about the quality of their work will want to reduce the future cost of maintaining their software. According to the textbook, they can do this by using "Good software engineering techniques such as precise specification, test-first development, the use of object-oriented development, and configuration management" to help reduce the cost of future maintenance (Sommerville 259).  The ACM Software Engineering Code of Ethics says that a software engineer must "promote an ethical approach to the practice of the profession". This can only by done by carefully constructing software that is in the best interests of the employer (even if they do not require it), the client (who will have to pay for future maintenance), and the public (who want to use the software).  

</div>

# HW12: Chapter 16"

### 16.9 > Design the interfaces of components that might be used in a system for an emergency control room. You should design interfaces for a call-logging component that records calls made, and a vehicle discovery component that, given a post-code (zip code) and an incident type, finds the nearest suitable vehicle to be dispatched to the incident.

![image-asset.png](/image-asset.png "image-asset.png")


# "HW13: Chapter 17"
### 17.10 Your company wishes to move from using desktop applications to accessing the same functionality remotely as services. Identify three risks that might arise and suggest how these risks may be reduced.

<div style = "color:red">
    
 Security -Information is being moved remotely once the company switches to using remote software.  When information was being transferred locally the security belonged only to the company.  The information being transferred through SaaS goes from the company then to the SaaS.  Information can be at risk if not thoroughly protected.  Security issues can be reduced if the SaaS has a up to date security procedures, or a third party can be hired to maintain security.
 Redundancy –  If the server or system of that runs the remote service goes down and fails, the ability for companies to continue to function is a must.  Having a backup system is with minimal functionality or a desktop version can be used until the system is back up.
 Connectivity – Since the software will be remotely used, the use of the software is no longer in the companies control.  They are completely in the hands of their internet provider as which is the speed that they can access the information.  There is no fool proof plan for this, internet connections are stable most times, but will go out from time to time.  If it happens often, changing providers may be the answer.
</div>

# HW 14: Chapter 18"
### 18.4. Define an interface specification for the Currency Converter and Check credit rating services shown in Figure 18.7
  <div style = "color:red">
     
   Currency Converter:
utility service
task-oriented
not independent; relies on access to current exchange rates
state not stored
Interface:
<interface name = “currency-converter” >
  <operation name = “get-conversion” pattern = “wsdlns: in-out”>
    <input messageLabel = “In” element = “c-conv:from-amt” />
    <input messageLabel = “In” element = “c-conv:from-curr” />
    <input messageLabel = “In” element = “c-conv:to-curr” />
    <output messageLabel = “Out” element = “c-conv:to-amt” />
    <outfault messageLabel = “Out” element = “c-conv:InDataFault” />
  </operation>
</interface>



REST:
no security required, ease of access primary importance
Example url-based REST implementation:
baseurl/ ? amount= VALUE & from= CURRENCY & to= CURRENCY






Credit Rating:
more secure, autentication required(?)
business service
task-oriented
not independent; relies on access to credit monitoring systems
state not stored






Interface:
<interface name = “credit-retriever” >
  <operation name = “get-credit” pattern = “wsdlns: in-out”>
    <input messageLabel = “In” element = “c-conv:user-ID” />
    <input messageLabel = “In” element = “c-conv:password” />
    <input messageLabel = “In” element = “c-conv:target-ssn” />
    <output messageLabel = “Out” element = “c-conv:cred-score” />
    <outfault messageLabel = “Out” element = “c-conv:InDataFault” />
  </operation>
</interface>






SOAP:
Should require authentication & more advanced user logging
Shouldn’t be URL-based due to the inherent security required regarding usage of SSNs
Must track users & permissions within the system
    </div>
    
# HW15: Ex 19.3  
### 19.3 > Why is it impossible to infer the emergent properties of a complex system from the properties of the system components?

  <div style = "color:red">    
 The emergent properties of a system characterize the entire system - all of a system's components' properties are included in this as well as their ability to work together. The emergent properties include properties such as performance, reliability, usability, safety, and security. A component can often be considered reliable, safe, etc. when functioning on its own, but when it is a part of a system, those properties are not enough. Emergent properties encompass component properties as well as defining whether the components work together or not. It is difficult to distinguish emergent properties of a complex system from the system components because the emergent properties depend on the components working as expected.
    </div>
    
 # HW16: Chapter 20 
 ### 20.10 > You work for a software company that has developed a system that provides information about consumers and that is used within a SoS by a number of other retail businesses. They pay you for services used. Discuss the ethics of changing the system interfaces without notice to coerce users into paying higher charges. Consider this question from the point of view of the company's employees, customers, and shareholders.
 
   <div style = "color:red">  
  No! This is terrible. I am sure from the shareholder perspective, they would not mind if the users were not informed of the increase in price, but this is completely unethical. A software company has a lot of power when it comes to hiding things from the public and from their customers, but they should not take advantage of this. The employees of the software company might feel uncomfortable with having to make this unethical change to the system, but will probably be unlikely to speak up in case they lose their jobs. Customers, being unaware of the change, will not have an opinion UNTIL (because it is bound to come out eventually) it is found out that the software company increased prices without notifying consumers. Then the shareholders will pretend they had no idea and blame it on the developers. The employees will probably be out of a job anyway once the consumers find out about everything, and then those employees have a stain on their record for the rest of their careers. So, all in all, it is a terrible idea, both for ethical reasons and practical ones.
    </div>
    
    
  # HW17: Team Progress I"
  
  <div style = "color:red">  
  I think our team is contributing well together . I am very lucky to having hardowrking and deciated team memnbers like Clare and Kat. We are always ahead of the game and completing the deliverables before they are do . Due to the fact we are always ahead of the game and schedule meeting week in advance i never feel like we our overowkring ourselves because we giver us some much time to do the assigments . Typically Fanastic 4  team member met  every Saturday at 1pm to update everyone about our progress in the things we are working on or have not completed and are next steps after that. Being that we have been ahead we have not been metting on Saturday due to the fact we completed everthing . However, if you saw are messages you will a non stop texting making sure everyone okay. I feel due to our nature and detirmination we are not missing out from a classroom setting.  I feel that our team can produce the same quality, be that remotely or in person. To finished thing up our professor did an amazing job pciking our teams … The Fantastic 4 team is a great team ! I am glad and proud to have such detirmined and smart teammates.  We all have own unquie skills that we bring to the team . Overall i have no complaints 
   </div>
   
# HW18: Chapter 21 and Chapter 22"

### 21.4. Explain why an object-oriented approach to software development may not be suitable for real-time systems.

  <div style = "color:red">  
   Object-oriented software languages are not the best to use for real-time systems. This is because these do have have the support needed to real-time concurrency problem        handlers. These do not have the support for the management of shared resources. This makes it more difficult to find, catch, and fix problems that arise.
   </div>
      
###  22.6 .Fixed-price contracts, where the contractor bids a fixed price to complete a system development, may be used to move project risk from client to contractor.  If anything goes wrong, the contractor has to pay. Suggest how the use of such contracts may increase the likelihood that product risks will arise.

  <div style = "color:red">  
    Fixed-price contracts are attractive to potential software development clients because it guarantees them a predetermined budget and also allows for all the risk to be          taken up by the contractor. Fixed-price contracts mean that the contractor takes on any extra costs that could incur because of changes in requirements or technology           that affect the timeline for the project's completion. While this may be a benefit for the customer, who will have more power to change their mind and project                   requirements, it is much more likely that product risks will arise because of bad communication, changes in plans, and off-schedule development. And all of these               problems will be up to the contractor to take care of, which does not seem like a smart business plan.
</div>

# HW19: Chapter 23"
### Figure 23.14 shows the task durations for software product activities. Assume that a serious, unanticipated setback occurs, and instead of taking 10 days, task T5 takes 40 days. Draw up new bar chart showing how the project might be reorganized.
 ![chart](/chart.png "chart")





# HW20:Team Progress II"

 <div style = "color:red">
    
 The Fantastic-Four team had some rough patches in terms of things we had to fix. We were making things complicated for ourselves when it did not have to be that complicated. Overall as the team though we are doing great. We been working together as a team and fixed the problem a sooon as we could. Some of the issues we faced where: changing the directory where the runAllTests method procees and runs. We discussed it in our methods and fixed the problem . I beleive communication is key and that what make us such a good group . After that we all came togehter and created the presentatipn and report and gave each other roles that we thought best fitted us and best suited us to talk about. The overall assesement is that  Fantastic-Four team is still in their prime like new born baby even with all the stuff thrown at us . I am glad to have Clare and Kat on my team 
</div>

# "HW21: Chapter 24"

### 24.6. Explain why program inspections are an effective technique for discovering errors in a ­program. What types of error are unlikely to be discovered through inspections?


 <div style = "color:red">
   
   1. They can find several faults in one pass without being concerned about interference between program faults. 
   
   2. They bring a number of people with different experience of different types of errors. Hence, the team approach offers greater coverage than any individual can bring. 

   3. They force the program author to re-examine the program in detail - this often reveals errors or misunderstandings. 

   The types of errors that inspections are unlikely to find are specification errors or errors that are based on a misunderstanding of the application domain (unless there       are domain experts in the team). 

   </div>


